## DIS: donut inflection syntax

Donut uses a custom written two-level compiler to handle inflections and adaptations to phonological context. The inflection is generated on the lowest level and the phonological rules are used to generate the surface form. 

```
wonen		*input*

↓

ge{won+D 	*internal level*

↓

gewoond		*surface level*

```

### Morphological syntax

#### Input

An inflection looks as follows:

```
ge-!ver-!be[-en]&D
```

The example is the inflection rule for a regular past participle in Dutch, it accepts an infinitive regular verb as input. Let's break down the syntax:

##### Stem

The regular verb stem in Dutch is formed just by taking the infinitve ending *-en* away. The rules for forming the stem are placed inside `[square brackets]`. There can be multiple stem rules, separeated by a `; semicolon`. There are two operators allowed inside the stem brackets:

* `+` adds something to the input word.
* `-` removes something from the input word.


###### Conditions

Inflection rules allow for conditions. If the condition is met, the operation will be preformed, if it is not met, the operation won't be done. Conditions are optional, if none is given, the operation will always happen.


* `-^x` - the operation will only be preformed if the word/stem starts with *x*. 
* `-$x` - the operation will only be preformed if the word/stem ends with *x*. 
* `-!^x` - the operation will only be preformed if the word/stem does not start with *x*. 
* `-!$x` - the operation will only be preformed if the word/stem does not end with *x*. 

See the following example, where *-en* is only removed from the end of a word, if the word does not end in *-eren*. 

```
[-en-!$eren]
```

##### Prefixes and suffixes

Prefixes and suffixes are placed before and after the stem at their respective possitions. Multiple affixes are allowed, separated by a `; semicolon`. The advantage of having them seperated is that the phonological rules can be more exact that way. 

For example, the swedish word *flickorna* (flick-or-na) from *flicka*, will have the following rule:
```
[-a]or;na
```

Each affix is added to the word with a seperator: `{` for prefixes and `+` for suffixes. These seperators can be used in the phonogical rules to match on. That is really handy when a phonological rule only applies when there is a certain ending, that way it is easy for the two level compiler to know whether a morpheme-boundary is present.


Affixes allow for conditions as well, just like the stem rules. Please note that the location of the condition (*start* `^` or *end* `$`) needs to be specified

`ge-!^ver-!^be[stem]`→ The Dutch prefix *ge-* is only added to the past participle if the stem does not start with *ver-* or *be-*. That allows for the past participle *verhuisd* from *verhuizen*, to be generated by one and the same rule.

##### Infixes

Sadly the two level compiler does not yet allow for infixes, if you have any suggestions in how this could be achieved, please contact me.

##### Ignored/alternative characters 

The two level compiler automatically outputs to lowercase. That means that uppercase letters can be used on internal level to avoid certain phonological rules. The lexical pattern of a word might be altered to contain an uppercase letter, if the word in questions needs to avoid a phonological change. In Dutch, for example, all *e*'s are doubled in certain phonological context (lezen -> lees), if this needs to be avoided (i.e. in ***schilderen* -> *schilderde* **not** *schildeerde*), the lexical form can be `schildEren`, that way that E does not get affected.

Uppercase letters can also be used to attract alternative phonological rules. In that cases, there needs to be matched on an uppercase letter in the phonological rule.

##### Variables

The inflection might generate a variable the can later bechanged by the phonological rules. The past participle example uses a variable **&D** as a variable, that is changed to either **d** or **t** depending on the phonological context. 

Variables have the following form `&name`. The prefered name for a variable is one of its surfaces forms in uppercase, `&D` for example, but names are not limited to only one character. 

If a phonological rule does not use a variable, it will be rendered to the surface as its name!

### Phonological syntax

The phonological rules are applied to all inflections after the internal level is generated. The phonological rules make use of regular expressions, but have a simplified syntax. See the example below that is used to make a *t* out of the variable *D* when the stem of a verb ends in a voiceless consonant. 

```
[x,k,f,s,c,h,p].+_&D_=>t
```

#### Format

`{left context}_{middle context}_{right context}=>{changes}`

#### The middle context

The middle context is what the regular expressions matched on and it is the only thing affected by the rule. The middle context is changed to what is specified in the part after the `=>`. In the example rule, the `D` is changed to a `t`. 

#### The left and right contexts

Both contexts are optional, if no context is specified the rule applies to all matches of the middle context. The middle context is only affected if it is situated in the exact context specified by the rule. The example rule only has a left context, so let's take a look at another rule.

```
CON_[aeou]_CON.+.&D,T=>%%
```

Here we have a left context that is a `groupstring`, CON for consonant. The middle context can be one of the specified vowels. And the right context contains of three parts, separted by a dot, that is: a consonant, a morpheme boundary (right-side) and either a variable D or T. The replace specification contains two `%`'s, the symbol that is used to represent the part of the middle context that the regular expression matched on. 

This rule will double *a, e, o* and *u* in this exact context. That's how our example `ge{won+D` becomes `gewoond`.

#### Replace syntax

Groupstrings do not work in the replace syntax, the only special variable that can be used there is `%`, which matches the middle context. I.e `%%` will double `t`, if the `t` is the middle context.

In future versions of DIS it may become possible to backreferce to left and right context values. (i.e. `(:-1)` for the first character left from the middle context). 

#### Context syntax

Each context can match on multiple characters, separated by a dot. `a.b.c` means that is will match on *abc*. Each value in a context represents a single character. 

##### Groupstrings

In the language's alpabet, single graphemes can be linked to a groupstring. The groupstring is uppercase and 3 characters long. By default `VOW` represents every vowel and `CON` every consonant. The default groups can be changed and own groups can of course be created. 

##### Variable matching

Matching on a variable happens just with the variables form: `&name`. Matching on multiple variables is allowed by separating names with commas: `&foo,bar`.

##### Wildcard

The wildcard (`*`) matches on any character. 

##### Morpheme boundaries and compound words

`{`, `+` and `#` are morpheme boundaries. `{` for prefixes (left-side), `+` for suffixes and `#` as a spare boundary to be generated by a phonological rule. `::` is a boundary for compound words (needs to be specified on the lexical level).

##### Groups
`[a,b,c]` will match on *a, b* or *c*.

##### Word boundaries
`<:` matches on a word boundary on the left side, while `:>` matches on the right side.

##### Negative matches
`[^a]` will match on anything that is not a. `^CON` will match on anything that is not a consonant. 

##### Backreference
`%` matches the middle context match, for now it only works in the rightside context.

### From internal syntax to surface

The internal syntax is converted to lowercase and all special syntax (`+`, `#`, `{`, `::`) is removed. If your language needs capitalisation of the surface, that can be specified in the two level compiler via settings in the admin panel or manually in the code: `$twolc->setCapitalisation(true);`. Capitalisation can also be specified for semantical tags of lexical items (for languages for example).

## Cheat sheet

| Expression    | Meaning           |
| ------------- |:-------------:|
| `[-foo;+bar]`     | Form the stem by taking away -foo and adding bar |
| `;`     | Separate operations |
| `x;y[-foo]`      | Prefix: Add first *x* before the stem, then *y*      |
| `[-foo]x;y`      | Suffix: Add first *x* after the stem, then *y*      |
| `[-foo-^x]`      | Remove *-foo* only when the word starts with *x*;      |
| `[-foo-$x]`      | Remove *-foo* only when the word ends with *x*;      |
| `[-foo-!^x]`      | Remove *-foo* only when the word does not start with *x*;      |
| `[-foo-!$x]`      | Remove *-foo* only when the word does not end with *x*;      |
| `&X`      | Defining a variable in the inflection.      |
| `_x_=>y`      | A minimal phonological rule, without any contexts. This changes all *x*'s to *y*'s     |
| `y.z_x_.y.z=>y`      | Changes *x* to *y* when it is placed with a *y* and a *z* at the left side **and** the same on the right side  |
| `y.z_x_.y.z=>y`      | Changes *x* to *y* when it is placed with a *y* and a *z* at the left side **and** the same on the right side  |
| `CON.VOW`      | A context that consists of a consonant, then a vowel  |
| `^CON`      | Anything that is not a consonant  |
| `[x,y]`      | *x* or *y* |
| `[^x,y]`      | Anything that is not *x* or *y* |
| `&X`      | Match on variable `&X` |
| `&X,Y`      | Match on variables `&X` and `&Y` |
| `+, {, #, ::, 0, &`      | Special characters that are removed at the surface |



