## DIS: donut inflection syntax

Donut uses a custom written two-level compiler to handle inflections and adaptations to phonological context. The inflection is generated on the lowest level and the phonological rules are used to generate the surface form. 

```
wonen		*input*

↓

ge{won+D 	*internal level*

↓

gewoond		*surface level*

```

### Morphological syntax

#### Input

An inflection looks as follows:

```
ge-!ver-!be[-en]D
```

The example is the inflection rule for a regular past participle in Dutch, it accepts an infinitive regular verb as input. Let's break down the syntax:

##### Stem

The regular verb stem in Dutch is formed just by taking the infinitve ending *-en* away. The rules for forming the stem are placed inside `[square brackets]`. There can be multiple stem rules, separeated by a `; semicolon`. There are two operators allowed inside the stem brackets:

* `+` adds something to the input word.
* `-` removes something to the input word.

The stem forming rules allow for negative condition, which means nothing more that when the condition is met, the operation will not be preformed. The operator for negative condtions is `-!^` for a check from the start of a word and `-!$` to check from the end of a string. See the following example, where *-en* is only removed from the end of a word, if the word does not end in *-eren*. 

```
[-en-!$eren]
```

##### Prefixes and suffixes

Prefixes and suffixes are placed before and after the stem at their respective possitions. Multiple affixes are allowed, separated by a `; semicolon`. The advantage of having them seperated is that the phonological rules can be more exact that way. 

Each affix is added to the word with a seperator: `{` for prefixes and `+` for suffixes. These seperators can be used in the phonogical rules to match on. That is really handy when a phonological rule only applies when there is a certain ending, that way it is easy for the two level compiler to know whether a morpheme-boundary is present.


Affixes allow for negative condtions, just like the stem forming rules. The only difference is that the position for the check does *not* have to be specified, but it is allowed, if for example a prefix is only added when the stem ends in a certain vowel. If no position is given, the front is assumed in prefixes and the back in suffixes.

`ge-!ver-!be[stem]`→ The Dutch prefix *ge-* is only added to the past participle if the stem does not start with *ver-* or *be-*. That allows for the past participle *verhuisd* from *verhuizen*, to be generated by one and the same rule.

##### Infixes

Sadly the two level compiler does not yet allow for infixes, if you have any suggestions in how this could be achieved, please contact me.

##### Variables and ignored characters

Uppercase letters can be used as variables that later can be changed by the phonological rules. The two level compiler automatically outputs in lowercase on the surface. The past participle example uses an uppercase **D** as a variable, that is changed to either **d** or **t** depending on the phonological context. 

If a certain letter is not used as a variable in a phonological rule, it can be used to avoid changes by phonological rules, most of the time the lexical form of some words may need such a letter. In Dutch, for example, all *e*'s are doubled in ceratin phonological context (lezen -> lees), if this needs to be avoided (i.e. in **schilderen* -> *schilderde* **not** *schildeerde*), the lexical form can be `schildEren`, that way that E does not get affected.

Future versions of DIS might have a different notation for variables, for example something like `&d`.

### Phonological syntax

The phonological rules are applied to all inflections after the internal level is generated. The phonological rules make use of regular expressions, but have a simplified syntax. See the example below that is used to make a *t* out of the variable *D* when the stem of a verb ends in a voiceless consonant. 

```
[x,k,f,s,c,h,p].+_D_=>t
```

#### Format

`{left context}_{middle context}_{right context}=>{changes}`

#### The middle context

The middle context is what the regular expressions matched on and it is the only thing affected by the rule. The middle context is changed to what is specified in the part after the `=>`. In the example rule, the `D` is changed to a `t`. 

#### The left and right contexts

Both contexts are optional, if no context is specified the rule applies to all matches of the middle context. The middle context is only affected if it is situated in the exact context specified by the rule. The example rule only has a left context, so let's take a look at another rule.

```
CON_[aeou]_CON.+.[DT]=>%%
```

Here we have a left context that is a `groupstring`, CON for consonant. The middle context can be one of the specified vowels. And the right context contains of three parts, separted by a dot, that is: a consonant, a morpheme boundary (right-side) and either a variable D or T. The replace specification contains two `%`'s, the symbol that is used to represent the part of the middle context that the regular expression matched on. 

This rule will double *a, e, o* and *u* in this exact context. That's how our example `ge{won+D` becomes `gewoond`.

#### Replace syntax

Groupstrings do not work in the replace syntax, the only special variable that can be used there is `%`, which matches the middle context. I.e `%%` will double `t`, if the `t` is the middle context.

In future versions of DIS it may become possible to backreferce to left and right context values. (i.e. `(:-1)` for the first character left from the middle context). 

#### Context syntax

Each context can match on multiple characters, separated by a dot. `a.b.c` means that is will match on *abc*. Each value in a context represents a single character. 

##### Groupstrings

In the language's alpabet, single graphemes can be linked to a groupstring. The groupstring is uppercase and 3 characters long. By default `VOW` represents every vowel and `CON` every consonant. The default groups can be changed and own groups can of course be created. 

##### Wildcard

The wildcard (`*`) matches on any character. 

##### Morpheme boundaries and compound words

`{`, `+` and `#` are morpheme boundaries. `{` for prefixes (left-side), `+` for suffixes and `#` as a spare boundary to be generated by a phonological rule. `::` is a boundary for compound words (needs to be specified on the lexical level).

##### Groups
`[a,b,c]` will match on *a, b* or *c*.

##### Word boundaries
`<:` matches on a word boundary on the left side, while `:>` matches on the right side.

##### Negative matches
`[^a]` will match on anything that is not a. `^CON` will match on anything that is not a consonant. 

##### Backreference
`%` matches the middle context match, for now it only works in the rightside context.

### From internal syntax to surface

The internal syntax is converted to lowercase and all special syntax (`+`, `#`, `{`, `::`) is removed. If your language needs capitalisation of the surface, that can be specified in the two level compiler via settings in the admin panel or manually in the code: `$twolc->setCapitalisation(true);`. Capitalisation can also be specified for semantical tags of lexical items (for languages for example).